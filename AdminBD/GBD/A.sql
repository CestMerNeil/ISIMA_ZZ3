Abstract. In November 2000, the OMG made public the MDATMinitiative, a particular variant of a new global trend called MDE (Model Driven Engineering). The ba- sic ideas of MDA are germane to many other approaches such as generative programming, domain speciﬁc lan- guages, model-integrated computing, generic model man- agement, software factories, etc. MDA may be deﬁned as the realization of MDE principles around a set of OMG standards like MOF, XMI, OCL, UML, CWM, SPEM, etc. MDE is presently making several promises about the potential beneﬁts that could be reaped from a move from code-centric to model-based practices. When we observe these claims, we may wonder when they may be satisﬁed: on the short, medium or long term or even never per- haps for some of them. This paper tries to propose a vi- sion of the development of MDE based on some lessons learnt in the past 30 years in the development of object technology. The main message is that a basic principle (“Everything is an object ”) was most helpful in driving the technology in the direction of simplicity, generality and power of integration. Similarly in MDE, the basic principle that “Everything is a model ” has many inter- esting properties, among others the capacity to generate a realistic research agenda. We postulate here that two core relations (representation and conformance) are as- sociated to this principle, as inheritance and instantia- tion were associated to the object uniﬁcation principle in the class-based languages of the 80’s. We suggest that this may be most useful in understanding many ques- tions about MDE in general and the MDA approach in particular. We provide some illustrative examples. The personal position taken in this paper would be useful if it

1	Introduction

There is presently an important paradigm shift in the ﬁeld of software engineering that may have important consequences on the way information systems are built and maintained. Presenting their “software factor y” ap- proach, J. Greenﬁeld and K. Short write in [14]:
“The software industry remains reliant on the craftsmanship of skilled individuals engaged in labor intensive manual tasks. However, growing pressure to reduce cost and time to market and to improve software quality may catalyze a tran- sition to more automated methods. We look at how the software industry may be industrialized, and we describe technologies that might be used to support this vision. We suggest that the current software development paradigm, based on object orientation, may have reached the point of exhaus- tion, and we propose a model for its successor.”
The central idea of object composition is progressively being replaced by the notion of model transformation. One can view these in continuity or in rupture. The idea of software systems being composed of interconnected ob- jects is not in opposition with the idea of the software life cycle being viewed as a chain of model transformations.
In this paper we compare the evolution and achieve- ments of object technology in the past period with the new proposals and claims of MDE. The main message is that a basic principle in object technology (“Everything is an object” [P1]) was most helpful in driving the technol- ogy in the direction of simplicity, generality and power of integration. Similarly in MDE today, the basic principle that “Everything is a model” [P2] has many interesting properties, among others the capacity to generate a re- alistic research agenda, as will be detailed in Sect. 5. We suggest that this may be most useful in understanding many questions about MDE in general and the MDATM approach in particular.

As suggested by Figs. 1 and 2, the core conceptual tools that were in focus in the 80’s are being renewed. At the beginning of object technology, what was import- ant was that an object could be an instance of a class and a class could inherit from another class. This may be seen as a minimal deﬁnition in support of principle [P1]. We call the two basic relations instanceOf and inherits- From. Very diﬀerently, what seem to be important now is that a particular view (or aspect) of a system can be cap- tured by a model and that each model is written in the language of its metamodel. This may be seen as a mini- mal deﬁnition in support of principle [P2]. We call the two basic relations representedBy and conformsTo. It is very likely that the discussions on the exact meaning of these two central relations associated to principle [P2] will take some time to settle. Similarly to the sometimes-heated initial discussions on the two relations related to principle [P1] of object-oriented programming, this is also likely to generate many lively debates. The deﬁnitions we propose here are very loose and preliminary, but we are still at the stage of identifying the hard core principles of MDE.
The danger would be to use the old [P1] relations within the new context of MDE, for example by stating

that a model in an instanceOf a metamodel1. This point of view often leads to many confusion and does not help in clarifying a complex evolution.
Separate consideration of the set of relations [P1] and [P2] will also help to assess that MDE and the ob- ject technology views of the software development world should not be considered as opposite but as complemen- tary approaches.
The MDE approach has not a unique goal. Among the objectives pursued, one may list the separation from business-neutral descriptions and platform dependent implementations, the identiﬁcation, precise expression, separation and combination of speciﬁc aspects of a sys- tem under development with domain-speciﬁc languages, the establishment of precise relations between these dif- ferent languages in a global framework and in particular the possibility to express operational transformations be- tween them.
Similarly, when object technology was introduced, it had no unique goal. In order to fulﬁll object technology multiple objectives, principle [P1] has been most helpful in the last period but seems now to have reached its limit for the increasingly complex and rapidly evolving systems we are building today. A complete new rise in abstraction seems absolutely necessary. Principle [P2] is a candidate for the paradigm shift corresponding to this important and necessary evolution.
To make this more concrete, let us take as an ex- ample one of the ﬁrst objective of MDA: separating the business part from the platform part of systems in order to independently control their evolution [27]. Applying

1 More generally, there is an over-usage of this instanceOf rela- tion in MDE. Used in diﬀerent contexts, with diﬀerent meanings, this may cause additional confusion. Careful distinction between at least three diﬀerent usages of this relation is suggested in [3] and [8].
 

 
principle [P1] to this problem yielded the MVC architec- ture where a pure business class (called a Model ) relates in a precise standard way with two other classes (called a View and a Controller ) handling platform-speciﬁc pre- sentation and rendering on one side and device-based dialogue control on the other side. The object technol- ogy abstraction mechanisms have partially contributed to solve the problem (GUI architecture). Unfortunately they fall short in solving it in its entirety (separating business from platform). The hope is to apply principle [P2] to the same problem in a very diﬀerent and more general way: a platform-based transformation could pro- duce an executable system from a business description, bound to this speciﬁc platform, from the neutral de- scription of a business system. The complete feasibility and practicability of this process has still to be demon- strated, but we can nevertheless see how diﬀerently both [P1] and [P2] attack this problem, with diﬀerent levels of ambition.
This paper is organized as follows. In Sect. 2 we look at object technology and how it has achieved progresses through the uniﬁcation principle. In Sect. 3 we discuss one view of the uniﬁcation principle in MDE. In Sect. 4 we review some examples of models for illustrative pur- pose. In Sect. 5 we show how a research agenda for MDE could be inferred from the generalized application of principle [P2].


2	The lessons of object technology

When we look at the two basic relations of Fig. 1, we ﬁnd them to be quite characteristic of object-technology. However this has not always been so clear. In program- ming languages like ThingLab [9], a partOf explicit rela- tion was also proposed as an integral part of the language. In other object-oriented languages like Self , the concept of class itself was absent and thus this language was not based on the set of relations of Fig. 1. In modern lan- guages like Java, the additional concept of Interface is also part of the scope. There were heated debates in the 80’s about the exact meaning of these relations, including the controversies between single and multiple inheritance. Nevertheless the deﬁnition of class-based program- ming languages like Java or C# are more or less based on the central organization depicted in Fig. 1, with rather consensual deﬁnitions of this set of relations. What we call an object is an instance of a class, this class possibly
inheriting from another class.
Based on these common assumptions, some languages may go beyond these deﬁnitions, for example by provid- ing more or less general metaclass organization schemes (a class being an instance of a metaclass). As a conse- quence, when we talk about an object, the context is im- portant. In a general context, we usually mean an entity corresponding to the scheme deﬁned in Fig. 1. If we need to be more speciﬁc, we refer to a C# object, a Java ob-
 
ject, a C ++ object, an Eiﬀel object, a CLOS object, etc., with usually additional properties.

2.1	Towards uniﬁcation
Since the inception of object technology, the uniﬁcation principle has been an engine for progress. The very basic idea of an object in Simula was a device that could unify data and process, a signiﬁcant ﬁrst step in achieving prin- ciple [P1]. Simula walked an initial path in this direction and its authors may be credited from having proposed the basic scheme of Fig. 1.
After Simula, the language that has probably most in- ﬂuenced the development of industrial object technology was Smalltalk . This language, through several iterations, going from Smalltalk-72 to Smalltalk 80 , tried to push as far as possible this idea that everything is an object in several ways:
–	Starting from the relations in Fig. 1, the considera- tion of classes as objects directly induced the neces- sity to consider metaclasses as independent entities. Furthermore the consideration of metaclasses as ob- jects made necessary to provide a global and regular scheme for organizing this system where the super- class of a metaclass was identical to the metaclass of the super-class. Other schemes like CLOS , ObjVlisp, etc. have also been proposed, that tried to push fur- ther this principle that everything is an object.
–	Considering integer or boolean values as objects was a radical position at the time since it lead to view the expression i + j as the sending of message + with argu- ment j to object i and not as the operator + applied to operands i and j. Of course the concept of prim- itive method allowed dealing with this uniform view without severe performance penalties. The distinction between primitive data types and object-based data types, at the language level, is probably not the best solution and Smalltalk avoided this pitfall by treating this distinction only at the implementation level. To this respect again, Smalltalk was an improvement on most of its successors, to use the famous formulation of
C.A.R. Hoare.
–	Another step was to consider messages themselves as objects. Here again the language designers managed to provide a uniform view with reasonable implemen- tation overhead by allowing messages to be reiﬁed as true objects when needed, i.e. for example on sending errors. In these cases the doesNotUnderstand : method could be used to deal with a real message object, in- stance of the MessageSend class.
–	As a last example we may also quote the eﬀorts to deal with methods as objects. The uniﬁcation of block closures and methods was not completely achieved in Smalltalk-80 , but the fact that block were true ob- jects allowed to investigate a lot of interesting issues, like extensible control structures built up from simple message passing mechanisms.
 

 
Many of these advances were unfortunately not selected in modern convergence languages like Java or C#. How- ever we can see that much progress in object technol- ogy has been made while this [P1] principle was actively pursued.

2.2	Incomplete achievements

On the contrary, the recent period of object technology shows many examples of situations where abandoning the quest for this [P1] principle has lead to some diﬃculties or at least some incomplete achievements. We may give some examples.
–	With procedural technology, the notion of multiple entry point could be used to deﬁne an application as a set of services. This was used in many methods based on stepwise reﬁnement in the 70’s. What mod- ern object-oriented programming languages have been able to oﬀer is that unique entry point philosophy, the “infamous” public static void main (Strings [] args). We probably missed one opportunity to represent, at the programming level, an application and its entry points by an object and its methods. In order to com- pensate this drawback on the programming side, I. Jacobson introduced the concept of Use Case in the UML language but this was outside the scope of the programming language itself. The impendence mis- match between these two views may partially explain the success today of service-oriented computing on object-oriented computing.
–	The ﬁrst real life deployment of object-oriented sys- tems showed that the complexity of such systems could not be only encapsulated in the class deﬁn- ition themselves, but in the subtle relations between these classes. The normal reaction was to invent a new language based on design patterns. Unfortunately, here also, the principle of uniﬁcation could not be fully applied. As a consequence design patterns can- not be seen, for the time being, as entities respecting principle [P1].
–	More recently, there was recognition that object- oriented techniques were not suﬃcient to express the various aspects on a system. The Aspect Oriented Programming movement is currently trying to ﬁnd solutions to this problem based on code-centric ap- proaches. The objective of considering aspects as full- ﬂedged objects, respecting principle [P1], has not yet been completely realized.
There are a lot of missed (or at least incompletely matched) opportunities in object-oriented technology [13]. One of the major ones was the rendezvous between ob- jects and the Web (it would have been a nice property if every object could have been identiﬁed by a URI). The marriage of objects and databases has produced limited results, far to corresponding to the initial hopes. In spite of many clever research ideas, the uniﬁcation of objects
 
and processes is not still achieved on practical basis (e.g. in workﬂow systems). We could also mention the limited contribution to reusability2. The origin of many of these problems may be traced to some form of abandoning the search for uniﬁcation after the Smalltalk period. As a con- sequence, object-oriented computing is no more in a situ- ation to play the role of an integration technology. Instead it is today in the state of a very useful technology to be integrated with other technologies like service-oriented computing and many others.

3	MDE: concepts and goals

As the notion of object was central to the software devel- opment practices of the 80’s, the notion of model seems today to focus much attention. The question of deﬁning what a model is, on a practical basis, will probably take as much time and energy to settle as the deﬁnition of the no- tion of an object. We propose in this paper to start from the two basic relations associated to principle [P2].

3.1	On the meaning of models

When we look at the general deﬁnition of a model, we ﬁnd a set of diﬀerent ones, some of them even being contra- dictories. For example, on the ten deﬁnitions given in the Encarta Encyclopedia [11], there are essentially two that corresponds to our purpose in the context of MDE:
“mod·el [m´odd’l] noun (plural mod·els)
1. copy of an object: a copy of an object, espe- cially one made on a smaller scale than the original (often used before a noun)
5. simpliﬁed version: a simpliﬁed version of something complex used, for example, to analyze and solve problems or make predictions a ﬁnancial model ”
These two meanings roughly correspond to the con- sensual deﬁnition given by J. Rothenberg in [25]:
“Modeling, in the broadest sense, is the cost- eﬀective use of something in place of something else for some cognitive purpose. It allows us to use something that is simpler, safer or cheaper than re- ality instead of reality for some purpose. A model represents reality for the given purpose; the model is an abstraction of reality in the sense that it cannot represent all aspects of reality. This allows us to deal with the world in a simpliﬁed manner, avoiding the complexity, danger and irreversibility of reality.”

2 Object technology promised for example application extensibil- ity through class inheritance. We know today that one important kind of application extensibility is implemented with plugins, as in the Eclipse system for example. This concept of plug-in does not owe much to class inheritance.
 

 
The word model comes from the Latin modullus through the Italian modello3 . Initially modullus was the diminutive of modus, meaning a special constraint ratio, used in architecture, between parts of a building in construction.
Modeling is essential to human activity because every action is preceded by the construction (implicit or ex- plicit) of a model. The medical technique of bloodlet- ting for example was based on an incorrect model of the body4. If the model is incorrect, the action may be inappropriate5.
There are plenty of practical usages of models: sta- tistical model, meteorological model, biological models, ecological models, economical models, etc. Computer sci- ence may be mainly described as the science of building software models. If the use of the word model in engin- eering sciences is quite recent, the idea itself goes back to ages. Plato (427-347 BC) in the Timaeus already used the concept of irrigation channels to describe blood vessels. Later, this same model was “reﬁned” by the English phys- iologist W. Harvey (1578–1657), to characterize the blood circulatory system.
The blood circulatory model is only one view or aspect on the human body among many others (skeleton, mus- cular, digestive, respiratory, endocrinous, nervous, etc.). The human body being the system, a diﬀerent model characterizes each aspect. This is the ﬁrst relation repre- sentedBy associated to principle [P2].
There are still a lot of tentatives for building models, for example models of the brain, of the human genome, etc. A process of trial and error usually elaborates models progressively. In human history, models that have con- centrated much energy are geographical models or maps. Even after the roundness of the earth was commonly ac- cepted, it took quite a time to the ﬁrst explorers to pro- gressively assess their maps of the world.
Today we are using a lot of diﬀerent maps. If one wishes to ride a bike or a truck through a given terri- tory, the map used will be diﬀerent. If one wants to visit museums or to rapidly drive on highways in the same area, diﬀerent maps of the same territory will also be use- ful. Map making is usually a human activity. In certain cases automation may help (e.g. satellite photography) and in very speciﬁc situations we can have automatic map production. Similar remarks will apply to automatic model production in the information system area. A map is a representation of a given territory. The ﬁrst relation

3 Another previous import of modullus in the Middle Ages also gave the word mould.
4 Hyppocrates and many others believed that the four crucial elements earth, air, water and ﬁre were balanced within the hu- man body as the four humors: blood, phlegm, and black and yellow bile. In this context, disease was due to an imbalance in the four humors and treatment involved restoring their balance through bloodletting.
5 Georges Washington died after heavy blood loss sustained in a bloodletting treatment for laryngitis.
 
(representedBy) of principle [P2] clearly appears in these situations.
This example of geographical maps has much inspired the reﬂection on modeling practices. The notion of pre- ciseness of a model for example has progressively been considered as a relative notion. A model is not intended to capture all the aspects of a system, but mainly to abstract out only some of these characteristics. Instead a system is usually represented by a set of diﬀerent models, each one capturing some speciﬁc aspects.
Many authors, from L. Carroll to J.-L. Borges or
U. Eco, have told the same story of people competing to build complete models of a system, for example maps at the 1:1 scale6. For example in “Mary and Bruno con- cluded ”, L. Carroll narrates the following story:
“That’s another thing we’ve learned from your Na- tion,” said Mein Herr, “map-making. But we’ve carried it much further than you. What do you con- sider the largest map that would be really useful?” “About six inches to the mile.”
“Only six inches!” exclaimed Mein Herr. “We very soon got to six yards to the mile. Then we tried a hundred yards to the mile. And then came the grandest idea of all! We actually made a map of the country, on the scale of a mile to the mile!”
”Have you used it much?” I enquired.
“It has never been spread out, yet,” said Mein Herr: “the farmers objected: they said it would cover the whole country, and shut out the sunlight! So we now use the country itself, as its own map, andI assure you it does nearly as well.
But there are many other lessons to be learnt from geographical maps as well. If we look at the map pre- sented in Fig. 3, we see in the bottom-left corner some information expressed, as in the remainder of the map, in a graphical form. But the nature of this information is diﬀerent from the one in the remainder of the map. It is a legend indicating how to interpret the map itself. A map would be useless without a legend. Loosing the legend and this map would be impossible to interpret. There may also be implicit elements in a map, for example the scale or the direction (the top of the map represents the North direction), etc.
We say that the map conforms to its legend, i.e. that the map is written in the (graphical) language deﬁned by its legend. This immediately generalizes to a model conforming to its metamodel, the second relation (con- formsTo) associated with principle [P2].
The relation between a model and its metamodel is also related to the relation between a program and the programming language in which it is written, deﬁned by its grammar, or between an XML document and the deﬁning XML schema or DTD.

6 This story may be usefully recalled when one tries to capture in a UML model the totality of aspects of a Java program.
 

 
Fig. 3. Map of France in 1453 from the Historical Atlas by R. Shepherd

 
Similarly to discussions that took place about the dis- tinction between instantiation and inheritance, there may also be discussions on the two relations associated to prin- ciple [P2]. One of them is particularly confusing on the meaning of the expression “the model of a model ”. This is usually shorthand for “coercing” the model as a system and extracting another model from it. For example we could have a map of the area of Seattle at scale 1:50 000. Then we could consider this map as a system and derive from it another map at scale 1:100 000. So the normal interpretation of “the model of a model” is more nat- urally related to the representedBy relation and not to a metamodel7. To make clearer this distinction, let us look at Fig. 4. This famous painting by R. Magritte reads “This is not a pipe” below the picture of a pipe, insist- ing on the fact that the painting of a pipe may be useful for several purposes, but certainly not to smoke tobacco. Similarly we may have a painting of the painting, and so on. This is what we call a model of a model but this is not a metamodel.
Of course this discussion may clarify the ﬁrst relation of [P2] (representedBy), but diﬃculties lay also in the deﬁnition of the second relation (conformsTo). The na¨ıve

7 Asked about the reason of interpreting “the model of a model is a metamodel”, a student answered that this was because he re- membered that “a class of a class is a metaclass”. This shows again at the same time the danger of approximations, uncontrolled analo- gies and mixing the two systems of relations associated to [P1] and [P2].
 

 
Fig. 4. “Ceci n’est pas une pipe”, painting by Magritte revisited


introduction to these concepts needs to be elaborated on a more precise and formal way. In particular, one dimen- sion that is absent in the previous discussion is the need for coordinating diﬀerent maps. Since we said that we will use diﬀerent maps to express diﬀerent views on a given territory, and since these maps may be jointly used, then we must take some actions to allow the coordination be- tween these views. Let us suppose that towns, on diﬀerent maps, are diﬀerently drawn. We would need to assess that these towns correspond to similar entities, enabling them to act as “join points” between diﬀerent views. We may state that each legend deﬁnes some kind of “domain spe-
 

 
ciﬁc language”, but how may these languages be related? The limits of the analogy show up here in this case, be- cause what we would need is a language for describing legends, what we shall call a metametamodel.
The postulate of the existence, in each technical space [18], of a unique metametamodel, is essential if we want to compare, transform, merge, make diﬀerences, etc. between diﬀerent models. In MDE this postulate is essential since the number of diﬀerent domain speciﬁc languages is very rapidly growing, with the danger of frag- mentation. In MDA, the unique metametamodel is the MOF (Meta-Object Facility).

3.2	From contemplative to operational models
One important diﬀerence between the old modeling prac- tices and modern MDE is that the new vision is not to use models only as simple documentation but as formal input/output for computer-based tools implementing precise operations. As a consequence model-engineering frameworks have progressively evolved towards solid pro- posals like the MDA deﬁned by the OMG. We may clearly see the three levels of principles (general MDE princi- ples as described in this paper), of standards (e.g. the OMG/MDA set of standards), and of tools (like the EMF, Eclipse Modeling Framework or the Visual Studio Team system).
Progressively we come to understand much better the possibilities and limits of this new way of considering in- formation systems. The notion of a metamodel is strongly related to the notion of ontology. A metamodel is a formal speciﬁcation of an abstraction, usually consensual and normative. From a given system we can extract a particu- lar model with the help of a speciﬁc metamodel. A meta- model acts as a precisely deﬁned ﬁlter expressed in a given formalism.
To make this more concrete, let us take one example. Suppose we want to consider a system S composed of sev- eral users accessing a UNIX operating system. We wish to take a model of this (Fig. 5). The ﬁrst step will be to de- ﬁne the aspects which we are interested in, and ignore the aspects we want to discard.

Fig. 5. Extracting a model from a system
 
We do this with a metamodel MMa like the following one:
class(User,Group,File,Directory,FileElement); association(belongsTo,User*,Group) association(owns,User,FileElement*) association(contains,Directory,FileElement*) inherits(File,FileElement); inherits(Directory,FileElement);
This means that we are only interested in Users, Groups of users and FileElements like Directories and Files. Furthermore, we would like to consider only the facts that a File or Directory is contained into a Direc- tory or is owned by a User or that a given User belongs to a Group. Simple multiplicity indication is provided here by starred names.
Metamodel MMa, applied to system S, will for ex- ample yield the following Ma model:
meta(Bob,User); meta(Jim,User); meta(Esther,User); meta(Mary,User);
meta(Student,Group); meta(Teacher,Group); meta(F1,File); meta(F2,File); meta(F3,File); meta(F4,File); meta(F5,File); meta(D1,Directory); meta(D2,Directory);
meta(D3,Directory); belongsTo(Esther,Teacher);
belongsTo(Mary,Teacher); belongsTo(Jim,Student); belongsTo(Bob,Student); owns(Esther,D1); owns(Esther,F1); owns(Mary,D2); owns(Mary,F2);
owns(Bob,D3); owns(Bob,F3);
owns(Jim,F4); owns(Jim,F5); contains(D1,F1); contains(D2,F2); contains(D3,F3); contains(D2,D3); contains(D1,F4); contains(D2,F5);
This means for example that User Jim belongs to the Student Group and owns File F 4, contained in Direc- tory D1. The relation conformsTo (Ma, MMa) is hold- ing at the global level and summarizes the various meta (X,Y) relations between any model element X and meta- model element Y .
It is worthwhile mentioning how this organization may lead at least to partial automation. One may un- derstand how a UNIX shell script P could automatically generate a model similar to Ma. This script may be com- posed of classical UNIX commands like ﬁnd , ls, grep, sed , awk , etc. The interesting question however is how far this script P could be derived from the speciﬁcation of metamodel MMa. By decorating each metamodel elem- ent of MMa with the UNIX code in charge of discover- ing the corresponding element (Class or Association), we progress towards this goal. Producing a model like Ma corresponds then to a graph exploration of metamodel MMa, with execution of the associated UNIX discovery code for each visited element.
We have used the textual notation of sNets [20] for deﬁning the MMa metamodel and the Ma metamodel
 

 
above. Of course, the same could also be expressed in a more classical way, like a visual UML-like notation, as suggested by Fig. 6. The use of visual notations may be very helpful, but is not one essential basic princi- ples of MDE. The visual expression of a metamodel as presented in Fig. 6 is a convenience. Since deﬁning meta- models is an activity much less frequent than deﬁning models, specialized tools for performing this task are not economically interesting to build. This is why usu- ally one has a tool for building models and will use it, in a special way, to build metamodels. Since the most popular metamodel in the MDA space is UML for the time being, the natural way is to use a UML case tool for building a metamodel. This is made even simpler by the alignment of the MOF (the standard lan- guage to write metamodels) with a limited subset of UML.
The basic use of a metamodel is that it facilitates the separation of concerns. When dealing with a given sys- tem, one may observe and work with diﬀerent models of this same system, each one characterized by a given metamodel. When several models have been extracted from the same system with diﬀerent metamodels, these models remain related and, to some extent, the op- posite operation may apply, namely combination of concerns.
The organization of the classical four-level architec- ture of OMG should more precisely be named a 3+1 ar- chitecture as illustrated in Fig. 7. At the bottom level, the M0 layer is the real system. A model represents this sys- tem at level M1. This model conforms to its metamodel deﬁned at level M2 and the metamodel itself conforms to the metametamodel at level M3. The metametamodel conforms to itself. This is very similar to the organiza- tion of programming languages. A self-representation of the EBNF notation takes some lines. This notation allows

Fig. 6. Another expression for the MMa metamodel
 

 
Fig. 7. The 3 + 1 MDA organisation


deﬁning inﬁnity of well-formed grammars. A given gram- mar, for example the grammar of the Pascal language, allows deﬁning the inﬁnity of syntactically correct Pascal programs.
As previously stated, one of the best-known metamod- els in the MDA is the UML metamodel. Many CASE tools have been built to support this graphical language. How- ever the real power of the MDA framework comes from the existence of level M3. This allows building coordi- nation between models, based on diﬀerent metamodels. One example of such coordination is model transform- ation, but there are many others that could be envisioned like model weaving. The existence, in the MDA, of the MOF recommendation [21] at level M3 allows using stan- dardized metamodels (like CWM, SPEM, EDOC, etc.). Furthermore the MOF allows deﬁning bridges between the MDA technical space and other spaces like the XML document space (through the XMI standard [23] for se- rialization) or the Java technical space (through the JMI standard for accessing model elements). Many other stan- dard projections could be useful as well like on mid- dleware spaces (CMI for CORBA Model Interchange). Separation between content and presentation of models may also be achieved by standard projection on render- ing spaces like SVG. So any MDA-model contains in- formation but lacks facilities to handle it. One classical possibility is to use projections to other technical spaces where these facilities are available. If we want to trans- port a model, than we may use the XMI projection on the XML space; if we want ﬁne-grained access to model elements, then we may use the JMI projection on the Java space; if we want to display the model, we may use projec-
 

 
tion on SVG space, and so on. Projections are associated to the MOF and may be seen as additional facilities of level M3.
